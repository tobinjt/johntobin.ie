[Project Euler problem
49:](http://projecteuler.net/index.php?section=problems&id=49)

> The arithmetic sequence, 1487, 4817, 8147, in which each of the terms
> increases by 3330, is unusual in two ways: (i) each of the three terms are
> prime, and, (ii) each of the 4-digit numbers are permutations of one another.
>
> There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes,
> exhibiting this property, but there is one other 4-digit increasing sequence.
>
> What 12-digit number do you form by concatenating the three terms in this
> sequence?

Here's my LISP solution:

doarrayi and doarray taken from
<http://unbox.org/wisp/var/bryan/lib/tricks/array.lisp>

    ; doarrayi and doarray taken from
    ; http://unbox.org/wisp/var/bryan/lib/tricks/array.lisp
    (defmacro doarrayi ((one n array &optional out) &body body)
      (let ((i (gensym)))
        `(let ((,i (length ,array)))
           (dotimes (,n ,i ,out)
             (let ((,one (aref ,array ,n)))
               ,@body)))))
    
    (defmacro doarray ((one array &optional out) &body body)
      (let ((j (gensym)))
        `(doarrayi (,one ,j ,array ,out) ,@body)))
    
    (defun make-n-element-lists (n the-list)
      (let ((num-elements (length the-list)))
        (cond
          ((> n num-elements)
            (error "make-n-element-lists: too few elements in list"))
          ((= n num-elements)
            (list the-list))
          (t
            (cons (subseq the-list 0 n) (make-n-element-lists n (rest the-list)))))))
    
    (defun powerset (the-set)
      (if the-set
        (let ((powersubset (powerset (rest the-set))))
          (append powersubset (mapcar #'(lambda (subset)
                                          (cons (first the-set) subset))
                                      powersubset)))
        (list '()) ))
    
    (defun project-euler-49-1 ()
      (let ((primes (sieve-of-eratosthenes 10000))
            (permutations (make-hash-table :TEST 'EQUAL)))
    
        ; Place primes into buckets where every number in a bucket is composed from
        ; the same digits.
        (doarrayi (is-prime i primes permutations)
          (when (and is-prime
                     (>= i 1000))
            (let ((sorted-digits (write-to-string (sort (number-to-digits i) #'<))))
              (setf (gethash sorted-digits permutations)
                    (cons i (gethash sorted-digits permutations))))))
    
        ; Some buckets will have more than three primes, and any three of those
        ; primes could be the trio we're searching for, so we construct the powerset
        ; of every bucket with more than three primes.
        (let ((list-of-lists-of-possible-answers '()))
          (maphash #'(lambda (_ bucket)
                       (declare (ignore _))
                       (if (< 3 (length bucket))
                         (push (powerset bucket) list-of-lists-of-possible-answers)
                         (push (list bucket) list-of-lists-of-possible-answers)))
                   permutations)
    
          ; Finally, filter out anything not matching the criteria.
          (remove-if #'null
                    (mapcar #'(lambda (list-of-possible-answers)
                                (remove-if-not #'(lambda (possible-answer)
                                                   (and (= 3 (length possible-answer))
                                                        (= (- (first possible-answer) (second possible-answer))
                                                           (- (second possible-answer) (third possible-answer)))))
                                               list-of-possible-answers))
                            list-of-lists-of-possible-answers)))))
    

[[!tag LISP Project_Euler programming]]
