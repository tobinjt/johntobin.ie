[Project Euler problem
41:](http://projecteuler.net/index.php?section=problems&id=41)

> We shall say that an n-digit number is pandigital if it makes use of all the
> digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital and is
> also prime.
>
> What is the largest n-digit pandigital prime that exists?

The largest pandigital number is 987,654,321.  There are 409,113 permutations
of 1 thing, 2 things, . . ., 9 things.  I could use Sieve of Eratosthenes to
find all primes up to 987,654,321, but that's a lot of memory and calculation;
instead, I'll generate permutations in descending order, and test each for
primeness using trial division.

Iteratively generating successive permutations uses far less memory than
recursively generating all permutations at once.  I haven't compared CPU usage.

Here's my LISP solution:

    (defun project-euler-41-1 ()
      (block pe41
        (do ((n 9 (1- n)))
            ((= n 0))
          (let ((elements (make-array n))
                (sum-of-elements 0))
            (do ((i 0 (1+ i)))
                ((= i n))
              (setf (aref elements i) (- n i))
              (incf sum-of-elements (aref elements i)))
            ; If a number is divisible by 3, the sum of its digits will be divisible
            ; by 3.  The digits don't change between permutations, so if their sum
            ; is divisible by 3, we can skip this group of digits entirely.
            (when (not (zerop (mod sum-of-elements 3)))
              (do ()
                  ((not elements))
                (let ((current-number (digits-to-number elements)))
                  (when (primep current-number)
                    (return-from pe41 current-number)))
                (setf elements (inplace-permute elements #'<))))))))
    
    (defun factorial (n)
      (reduce #'*
              (loop for i from 1 to n collect i)))
    
    (defun inplace-permute (elements comparator)
      "This generates the next permutation of the array ELEMENTS, modifying it
       in-place.  It returns ELEMENTS if it was permuted, or nil if there are no
       further permutations available.  The COMPARATOR argument determines whether
       the next permutation will ascend (e.g. >) or descend (e.g. <) from the
       current permutation.  It is the caller's responsibility to ensure that the
       array is sorted before this function is first called; also note that the
       first call will return the *second* permutation."
      ; http://en.wikipedia.org/wiki/Permute#Systematic_generation_of_all_permutations
      ;   The following algorithm generates the next permutation lexicographically
      ;   after a given permutation. It changes the given permutation in-place.
      ;   1 Find the largest index k such that a[k] < a[k + 1]. If no such index
      ;     exists, the permutation is the last permutation.
      ;   2 Find the largest index l such that k < l and a[k] < a[l]. Since k + 1 is
      ;     such an index, l is well defined.
      ;   3 Swap a[k] with a[l].
      ;   4 Reverse the sequence from a[k + 1] up to and including the final element
      ;     a[n].
    
      ; NOTE: tests using the comparator are negated, because we need #'< for
      ; ascending order, but that's counterintuitive for the caller, who'll ask:
      ; "Why do I get the permutation above the current one with less-than, and the
      ; permutation below with greater-than?".
      ; Step 1
      (let ((k))
        (do ((i 0 (1+ i)))
            ((>= i (1- (array-dimension elements 0))))
          (when (not (funcall comparator (aref elements i)
                                         (aref elements (1+ i))))
            (setf k i)))
        (when k
          ; Step 2
          (let ((l (1+ k)))
            (do ((i l (1+ i)))
                ((>= i (array-dimension elements 0)))
              (when (not (funcall comparator (aref elements k)
                                             (aref elements i)))
                (setf l i)))
            ; Step 3
            (rotatef (aref elements k) (aref elements l))
            ; Step 4
            (do ((lower (1+ k) (1+ lower))
                 (upper (1- (array-dimension elements 0)) (1- upper)))
                ((>= lower upper))
              (rotatef (aref elements upper) (aref elements lower))))
          elements)))

[[!tag LISP Project_Euler programming]]
