[Project Euler problem
44:](http://projecteuler.net/index.php?section=problems&id=44)

> Pentagonal numbers are generated by the formula, Pn=n(3n - 1)/2. The first ten
> pentagonal numbers are:
>
> 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
>
> It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their difference, 70
> - 22 = 48, is not pentagonal.
>
> Find the pair of pentagonal numbers, Pj and Pk, for which their sum and
> difference is pentagonal and D = |Pk - Pj| is minimised; what is the value of
> D?

This problem has five conditions:

1. x is pentagonal
2. y is pentagonal
3. |x - y| is pentagonal
4. (x + y) is pentagonal
5. |x - y| is minimised, i.e. no other pair of numbers (a, b) satisfying
conditions 1-4 has a smaller difference.

It turns out that the first pair meeting conditions 1-4 is the correct pair, and
many of the solutions on the Project Euler forum stop as soon as they find this
pair, but others ensure that condition 5 is also satisfied.  My solution ensures
that condition 5 is satisfied, because I believe it is more important to write a
correct program than to write a fast program.

Here's my LISP solution:

    (defun project-euler-44-1 ()
      (do ((best-pair)
           (best-difference)
           (numbers (list (pentagonal-number 1)) (cons current numbers))
           (current (pentagonal-number 2) (pentagonal-number n))
           (n 3 (1+ n)))
          ((and best-pair
                ; We've found the result when the difference between the last two
                ; pentagonal numbers is greater than the difference between the
                ; best-pair of pentagonal numbers.  I know that the first two
                ; numbers aren't a solution, so I'm not checking that numbers has at
                ; least two elements.
                (>= (- (first numbers) (second numbers))
                    best-difference))
           best-difference)
        ; Check each pairing of the current pentagonal number and the previous
        ; pentagonal numbers.
        (dolist (a-number numbers)
          (let ((sum (+ current a-number))
                (difference (- current a-number)))
            ; When we reach a pair whose difference is greater than the best pair's
            ; difference, terminate the loop.
            (when (and best-pair
                       (> difference best-difference))
              (return nil))
            (when (and (pentagonal-number-p sum)
                       (pentagonal-number-p difference))
              ; Is this pair better than the best pair?
              (when (or (null best-pair)
                        (< difference best-difference))
                (setf best-pair (list current a-number)
                      best-difference difference)))))))
    
    (defun pentagonal-number (n)
      "Returns the nth pentagonal number."
      ; Pn=n(3n - 1)/2
      (/ (* n (1- (* 3 n))) 2))
    
    (defun pentagonal-number-p (a-number)
      "Tests if p is pentagonal.  If p is pentagonal, returns n, where
       p is (pentagonal-number n).  Returns nil if p is not pentagonal."
      ; n=(sqrt(1 + 24x) + 1)/6
      (let ((n (/ (1+ (sqrt (1+ (* 24 a-number)))) 6)))
        (when (integerp n)
          n)))

[[!tag LISP Project_Euler programming]]
