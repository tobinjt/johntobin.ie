[Project Euler
problem 23:](http://projecteuler.net/index.php?section=problems&id=23)

> A perfect number is a number for which the sum of its proper divisors is
> exactly equal to the number. For example, the sum of the proper divisors of 28
> would be 1 + 2 + 4 + 7 + 14 = 28, which means that 28 is a perfect number.
>
> A number n is called deficient if the sum of its proper divisors is less than
> n and it is called abundant if this sum exceeds n.
>
> As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest
> number that can be written as the sum of two abundant numbers is 24. By
> mathematical analysis, it can be shown that all integers greater than 28123
> can be written as the sum of two abundant numbers. However, this upper limit
> cannot be reduced any further by analysis even though it is known that the
> greatest number that cannot be expressed as the sum of two abundant numbers is
> less than this limit.
>
> Find the sum of all the positive integers which cannot be written as the sum
> of two abundant numbers.

Here's my LISP solution:

    (defun factorise (a-number
      (let ((factors '()))
        (loop for current-divisor from 1 to (floor (sqrt a-number)) do
          (when (zerop (mod a-number current-divisor))
            (push current-divisor factors)
            (let ((other-factor (/ a-number current-divisor)))
              (when (and (not (= current-divisor other-factor))
                         (not (= a-number other-factor)))
                (push other-factor factors)))))
        (sort factors #'<)))
    
    (defun sum-factors (a-number)
      (reduce #'+ (factorise a-number)))
    
    (defun project-euler-23-1 ()
      (let* ((final-number 28123)
             (sum 0)
             (is-abundant (make-array (1+ final-number))))
        (loop for a-number from 1 to final-number do
          (setf (aref is-abundant a-number) (> (sum-factors a-number) a-number))
          (let ((sum-found nil))
            (loop for b-number from 1 to (/ a-number 2) until sum-found do
              (when (aref is-abundant b-number)
                (setf sum-found (aref is-abundant (- a-number b-number)))))
            (when (not sum-found)
              (incf sum a-number))))
        sum))

[[!tag LISP Project_Euler programming]]
