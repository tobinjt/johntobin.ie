[The twelfth Project Euler
problem:](http://projecteuler.net/index.php?section=problems&id=12)

> The sequence of triangle numbers is generated by adding the natural numbers.
> So the 7^(th) triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The
> first ten terms would be:
>
> 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
>
> Let us list the factors of the first seven triangle numbers:
>
>      1: 1
>      3: 1,3
>      6: 1,2,3,6
>     10: 1,2,5,10
>     15: 1,3,5,15
>     21: 1,3,7,21
>     28: 1,2,4,7,14,28
>
> We can see that 28 is the first triangle number to have over five divisors.
>
> What is the value of the first triangle number to have over five hundred
> divisors?

Here's my LISP solution:

    (defun project-euler-12-3 ()
      "More efficient trial division solution to Project Euler 12"
      (do ((n 2)
           (num-factors 0)
           (num-factors-n 0)
           ; The initial value is wrong, but the first loop iteration will correct
           ; it.
           (num-factors-n-1 0))
          ((> num-factors 500)
           (progn (decf n) (list n (/ (* n (1+ n)) 2) num-factors)))
    
        (setf num-factors-n-1 num-factors-n
              num-factors-n 0
              n (1+ n))
        (do* ((divisor 1)
              (n-to-divide (if (evenp n) (/ n 2) n))
              (max-divisor (1+ (ceiling (sqrt n-to-divide)))))
             ((> divisor max-divisor))
          (when (zerop (mod n-to-divide divisor))
            (incf num-factors-n)
            (when (not (= divisor (/ n-to-divide divisor)))
              (incf num-factors-n)))
          (incf divisor))
        (setf num-factors (* num-factors-n num-factors-n-1)))
    )

Discussion:

The obvious solution is trial division: divide by each number less than the
triangle number<sup>1</sup>, and count the number of factors you find.  This has
two problems: it's slow, and it's uninteresting ;)

A more interesting solution is available because *triangle number n* is
*sum-to-n* or *n(n+1)/2*, <!-- * --> so you can find the factors of *n* and
*n+1* separately, then multiply the counts to find the number of factors of the
triangle number.  It's a faster solution because you're factoring smaller
numbers (*n* instead of *n(n+1)/2*), <!-- * --> and you can cache results
between loop iterations: this iteration's *n* is the same as last iteration's
*n+1*.  <!-- * -->  You do need to take the */2* in the formula into account:
the simplest way is to divide *n* by 2 when *n* is even.

What effect does changing the algorithm have on performance?  The first solution
is O(n(n(n+1)/2))<sup>2</sup>, or O(n<sup>3</sup>) when the constant factors are
removed; it can be optimised<sup>1</sup> to O(n<sup>2</sup>).  The second
solution is O(n(sqrt(n)))<sup>3</sup>, or O(n<sup>3/2</sup>).  At first glance a
reduction of O(n<sup>1/2</sup>) doesn't look like much, but appearances can be
deceiving: *n* is 12375, so the change of algorithm reduces run time by two
orders of magnitude.

I think this is generally the correct approach to take to optimisation: use good
algorithms, and don't worry about micro-optimisation, because the gains from
using a good algorithm typically dwarf the gains from micro-optimising sections
of code.

1. Divide by each integer from 1 to *(ceiling (sqrt (sum-to-n n)))*  and
incrementing the number of factors by 2, instead of dividing by each number from
1 to *(sum-to-n n)*; <!-- * --> however, when the factor is *(sqrt n)* you only
increment by 1.

2. The unoptimised trial division algorithm is basically:

        (loop for i from 1 to n
            (loop for j from 1 to (sum-to-n n)
                ; is j a factor of (sum-to-n n)?
            )
        )

    Iterating from 1 to (sum-to-n n) is O(n(n+1)/2), or O(n<sup>2</sup>) when the
    constant factors are removed.  Optimising this approach changes the inner loop
    so it stops iterating at (sqrt (sum-to-n n)), and so the complexity is O(n).

3. The second algorithm is basically:

        (loop for i from 1 to n
            (loop for j from 1 to (sqrt n)
                ; is j a factor of n (n/2 when n is even)?
            )
        )

    That gives it complexity of O(n(sqrt(n))).

[[!tag LISP Project_Euler programming]]
