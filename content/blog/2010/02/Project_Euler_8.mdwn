[The eight Project Euler
problem:](http://projecteuler.net/index.php?section=problems&id=8)

> Find the greatest product of five consecutive digits in the 1000-digit number.
>
    73167176531330624919225119674426574742355349194934
    96983520312774506326239578318016984801869478851843
    85861560789112949495459501737958331952853208805511
    12540698747158523863050715693290963295227443043557
    66896648950445244523161731856403098711121722383113
    62229893423380308135336276614282806444486645238749
    30358907296290491560440772390713810515859307960866
    70172427121883998797908792274921901699720888093776
    65727333001053367881220235421809751254540594752243
    52584907711670556013604839586446706324415722155397
    53697817977846174064955149290862569321978468622482
    83972241375657056057490261407972968652414535100474
    82166370484403199890008895243450658541227588666881
    16427171479924442928230863465674813919123162824586
    17866458359124566529476545682848912883142607690042
    24219022671055626321111109370544217506941658960408
    07198403850962455444362981230987879927244284909188
    84580156166097919133875499200524063689912560717606
    05886116467109405077541002256983155200055935729725
    71636269561882670428252483600823257530420752963450

This is pretty simple: advance a sliding window along the number, multiplying
every group of five digits, remembering the largest product.  The only potential
difficulty I can see arises if you're using a language that doesn't support
integers greater than your native integer size (32 or 64 bit); if you start with
a number rather than a string, you may lose precision, your language's compiler
or runtime may choke on the number, or it may stringify to something like
*7316717.653133E993* that can't be used.  LISP doesn't suffer from this problem;
I wonder if large integer support is part of the original language, or was added
by the ANSI specification?

Here's my LISP solution:

    (defun get-digit (a-string index)
      (parse-integer (string (char a-string index)))
    )
    
    (defun project-euler-8-1 ()
      (let*
        (
          (the-number 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450)
          (the-number-string (write-to-string the-number))
          (number-of-digits 5)
          (digits-last-index (1- number-of-digits))
          (highest-product 1)
          (digits (make-string number-of-digits))
          (highest-digits (make-string number-of-digits))
        )
    
        ; populate digits and highest-digits
        (dotimes (i number-of-digits)
          (let
            (
              (digit (char the-number-string i))
            )
            (setf (char digits i) digit)
            (setf (char highest-digits i) digit)
            (setf highest-product (* (get-digit the-number-string i) highest-product))
          )
        )
    
        ; loop over the remaining digits in the-number-string
        (do
          (
            (i number-of-digits)
          )
          (
            (equal i (length the-number-string))
          )
    
          (let
            (
              (next-digit (get-digit the-number-string i))
              (product 1)
            )
            ; shift the current group of digits left
            (dotimes (j digits-last-index)
              (setf (char digits j) (char digits (1+ j)))
              (setf product (* product (get-digit digits j)))
            )
            ; append the next digit from the-number-string
            (setf (char digits digits-last-index) (char the-number-string i))
            (setf product (* product (get-digit digits digits-last-index)))
            (when (> product highest-product)
              ; update highest-product and highest-digits
              (setf highest-product product)
              (dotimes (j digits-last-index)
                (setf (char highest-digits j) (char digits j))
              )
            )
          )
    
          (setf i (1+ i))
        )
        (list highest-product highest-digits)
      )
    )


[[!tag LISP Project_Euler programming]]
