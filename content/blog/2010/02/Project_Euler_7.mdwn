[The seventh Project Euler
problem:](http://projecteuler.net/index.php?section=problems&id=7)

> By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
> that the 6^(th) prime is 13.
>
> What is the 10001^(st) prime number?

There are 25 primes in the first 100 numbers, and I thought that the number of
primes per hundred numbers dropped rapidly after that; it does, but not nearly
as rapidly as I thought.  Hmmm, I might create a graph - maybe the difference
between consecutive primes, or the mean difference between consecutive primes
over each group of 1000 integers?  Anyway, I digress.  This is a brute force
solution, but we're dealing with prime numbers, so we don't have many other
options.  My first thought was to use the [Sieve of
Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes), but that
requires an upper bound on the numbers being tested for primality.  Instead,
I used trial division, but with some cleverness:

* there's no need to divide by any number greater than the square root of the
number whose primality is being tested.

* there's no need to divide by composite numbers, just primes, because the
[Fundamental theorem of
arithmetic](http://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic)
tells us that every composite number can be expressed as a product of primes.

So although it's a brute force solution, it's pretty well optimised.

Here's my LISP solution:

    (defun project-euler-7-1 ()
      (let*
        (
          (number-of-primes 10001)
          (primes (make-zeroed-array number-of-primes))
          (first-prime 2)
          (next-prime-index 1)
          (current-number first-prime)
        )
    
        (setf (aref primes 0) first-prime)
        (do*
          (
          )
          (
            (equal number-of-primes next-prime-index)
          )
    
          (let*
            (
              (current-index 0)
              (current-prime (aref primes current-index))
              (max-divisor (sqrt current-number))
            )
    
            (loop
              (when (zerop current-prime)
                ; shouldn't happen; we ran off the end of the primes array
                (break "current-prime == 0")
              )
              (when (zerop (mod current-number current-prime))
                ; we found a divisor; current-number is not prime
                (return nil)
              )
              (when (> current-prime max-divisor)
                ; current-number is prime; save it, and move on to the next number
                (setf (aref primes next-prime-index) current-number)
                (setf next-prime-index (1+ next-prime-index))
                (return t)
              )
              (setf current-index (1+ current-index))
              (setf current-prime (aref primes current-index))
            )
    
            (setf current-number (1+ current-number))
          )
        )
        (aref primes (1- number-of-primes))
      )
    )

[[!tag LISP Project_Euler programming]]
