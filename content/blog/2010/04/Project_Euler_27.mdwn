[Project Euler
problem 27:](http://projecteuler.net/index.php?section=problems&id=27)

> Euler published the remarkable quadratic formula:
>
> n² + n + 41
>
> It turns out that the formula will produce 40 primes for the consecutive
> values n = 0 to 39. However, when n = 40, 402 + 40 + 41 = 40(40 + 1) + 41 is
> divisible by 41, and certainly when n = 41, 41² + 41 + 41 is clearly divisible
> by 41.
>
> Using computers, the incredible formula  n² - 79n + 1601 was discovered, which
> produces 80 primes for the consecutive values n = 0 to 79. The product of the
> coefficients, 79 and 1601, is 126479.
>
> Considering quadratics of the form:
>
> n² + an + b, where |a|  1000 and |b|  1000
>
> where |n| is the modulus/absolute value of n
> e.g. |11| = 11 and |4| = 4
> Find the product of the coefficients, a and b, for the quadratic expression
> that produces the maximum number of primes for consecutive values of n,
> starting with n = 0.

This is a brute force solution, with one optimisation: starting with *n = 0*
means that *n^2 + an + b* simplifies to just *b*, <!-- * --> so any *b* that
isn't prime can be skipped.

Here's my LISP solution:


    (defparameter primep-cache (make-hash-table))
    (defun caching-primep (an-integer)
      (multiple-value-bind (value present)
                           (gethash an-integer primep-cache)
        (if present
          value
          (setf (gethash an-integer primep-cache) (primep an-integer)))))
    
    (defun project-euler-27-1 ()
      (let* ((upper-bound 1000)
             (b-primes (sieve-of-eratosthenes upper-bound))
             (best-a)
             (best-b)
             (best-length 0))
        (loop for b from (- upper-bound) to upper-bound do
          (when (aref b-primes (abs b))
            (loop for a from (- upper-bound) to upper-bound do
              (let ((num-primes 0))
                (do* ((n 0 (1+ n))
                      (result (+ (* n n) (* a n) b)
                              (+ (* n n) (* a n) b)))
                     ((not (primep (abs result))))
                  (incf num-primes))
                (when (> num-primes best-length)
                  (setf best-a a
                        best-b b
                        best-length num-primes))))))
        (list best-a best-b best-length (* best-a best-b))))

[[!tag LISP Project_Euler programming]]
