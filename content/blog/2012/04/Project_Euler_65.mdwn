[Project Euler problem 65:](http://projecteuler.net/problem=65)

> See https://projecteuler.net/problem=65 - it's too hard to reproduce the formatting here.
> The square root of 2 can be written as an infinite continued fraction.
>
> The infinite continued fraction can be written, 2 = [1;(2)], (2) indicates that 2 repeats ad infinitum. In a similar way, 23 = [4;(1,3,1,8)].
>
> It turns out that the sequence of partial values of continued fractions for square roots provide the best rational approximations. Let us consider the convergents for 2.
>
> Hence the sequence of the first ten convergents for 2 are:
>
> 1, 3/2, 7/5, 17/12, 41/29, 99/70, 239/169, 577/408, 1393/985, 3363/2378, ...
> What is most surprising is that the important mathematical constant,
> e = [2; 1,2,1, 1,4,1, 1,6,1 , ... , 1,2k,1, ...].
>
> The first ten terms in the sequence of convergents for e are:
>
> 2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ...
> The sum of digits in the numerator of the 10th convergent is 1+4+5+7=17.
>
> Find the sum of digits in the numerator of the 100th convergent of the continued fraction for e.

This is the first Project Euler problem I've tackled and the first piece of LISP
I've written in ~8 months; I was a bit rusty, but I'm pleased with the result.

Here's my LISP solution:

    (defun sum-of-digits (a-number)
      (reduce #'+ (number-to-digits a-number)))

    (defun multiple-p (num divisor)
      " Return true if num is a multiple of divisor."
      (zerop (mod num divisor)))

    (defun e-to-depth (depth)
      "Calculate e to depth, starting from 1."
      ; depth 1 == 2 == 2
      ; depth 2 == 3 ==    (+ 2 (/ 1 1))
      ; depth 3 == 8/3 ==  (+ 2 (/ 1 (+ 1 (/ 1 2))))
      ; depth 4 == 11/4 =  (+ 2 (/ 1 (+ 1 (/ 1 (+ 2 (/ 1 1))))))
      ; depth 5 == 19/7 =  (+ 2 (/ 1 (+ 1 (/ 1 (+ 2 (/ 1 (+ 1 (/ 1 1))))))))
      ; depth 6 == 87/32 = (+ 2 (/ 1 (+ 1 (/ 1 (+ 2 (/ 1 (+ 1 (/ 1 (+ 1 (/ 1 4))))))))))
      ; 2 + 1
      ;     1 + 1
      ;         2 + 1
      ;             1 + 1
      ;                 1 + 1
      ;                     4
      ;
      ; Approach: start from the end of the equation and calculate back up.  The
      ; only minor complication is that every third number to add is (n * 2 / 3).
      (cond ((= 1 depth) 2)
            ((= 2 depth) 3)
            (t (flet ((next-in-seq (nn)
                        (if (multiple-p nn 3)
                          (/ (* 2 nn) 3)
                          1)))
                 (let ((result (next-in-seq depth)))
                   (dofromto ((1- depth) 2 n)
                     (setf result (+ (/ result) (next-in-seq n))))
                   (+ 2 (/ result)))))))

    (defun project-euler-65-1 ()
      (sum-of-digits (numerator (e-to-depth 100))))

[[!tag LISP Project_Euler programming]]
