[Project Euler problem 65:](http://projecteuler.net/problem=65)

See the problem for the full description - it's too hard to reproduce the
formatting here.

This is the first Project Euler problem I've tackled and the first piece of LISP
I've written in ~8 months; I was a bit rusty, but I'm pleased with the result.

Here's my LISP solution:

    (defun sum-of-digits (a-number)
      (reduce #'+ (number-to-digits a-number)))

    (defun multiple-p (num divisor)
      " Return true if num is a multiple of divisor."
      (zerop (mod num divisor)))

    (defun e-to-depth (depth)
      "Calculate e to depth, starting from 1."
      ; depth 1 == 2 == 2
      ; depth 2 == 3 ==    (+ 2 (/ 1 1))
      ; depth 3 == 8/3 ==  (+ 2 (/ 1 (+ 1 (/ 1 2))))
      ; depth 4 == 11/4 =  (+ 2 (/ 1 (+ 1 (/ 1 (+ 2 (/ 1 1))))))
      ; depth 5 == 19/7 =  (+ 2 (/ 1 (+ 1 (/ 1 (+ 2 (/ 1 (+ 1 (/ 1 1))))))))
      ; depth 6 == 87/32 = (+ 2 (/ 1 (+ 1 (/ 1 (+ 2 (/ 1 (+ 1 (/ 1 (+ 1 (/ 1 4))))))))))
      ; 2 + 1
      ;     1 + 1
      ;         2 + 1
      ;             1 + 1
      ;                 1 + 1
      ;                     4
      ;
      ; Approach: start from the end of the equation and calculate back up.  The
      ; only minor complication is that every third number to add is (n * 2 / 3).
      (cond ((= 1 depth) 2)
            ((= 2 depth) 3)
            (t (flet ((next-in-seq (nn)
                        (if (multiple-p nn 3)
                          (/ (* 2 nn) 3)
                          1)))
                 (let ((result (next-in-seq depth)))
                   (dofromto ((1- depth) 2 n)
                     (setf result (+ (/ result) (next-in-seq n))))
                   (+ 2 (/ result)))))))

    (defun project-euler-65-1 ()
      (sum-of-digits (numerator (e-to-depth 100))))

[[!tag LISP Project_Euler programming]]
