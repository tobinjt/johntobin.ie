[Project Euler problem
51:](http://projecteuler.net/index.php?section=problems&id=51)

> By replacing the 1st digit of *3, it turns out that six of the nine possible
> values: 13, 23, 43, 53, 73, and 83, are all prime.
>
> By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit
> number is the first example having seven primes among the ten generated
> numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and
> 56993. Consequently 56003, being the first member of this family, is the
> smallest prime with this property.
>
> Find the smallest prime which, by replacing part of the number (not
> necessarily adjacent digits) with the same digit, is part of an eight prime
> value family.

Here's my LISP solution:

    (defun get-digit-positions (a-number)
      "Returns an array of 10 lists, each list containing the indices where digit X
       can be found.  E.g.
          (get-digit-positions 1123)
       returns
          #(NIL (0 1) (2) (3) NIL NIL NIL NIL NIL NIL)"
      (let ((result (make-array 10)))
        (doarrayi (digit i (format nil "~A" a-number))
          (let ((index (char-to-number digit)))
            (setf (aref result index) (cons i (aref result index)))))
        (doarrayi (a-list i result result)
          (setf (aref result i) (nreverse a-list)))))

    (defun return-prime-family-candidates (prime)
      "Substitute all repeated digits in prime with '*', returning a list of
       generated strings, e.g
          (return-prime-family-candidates 56113)
       returns
          (\"5*113\" \"*6113\" \"5611*\" \"56**3\" \"56*13\" \"561*3\")"
      (let* ((positions (get-digit-positions prime))
             (position-powersets (map 'list
                                      #'powerset
                                      positions))
             (prime-string (format nil "~A" prime))
             (generated-strings '()))
        ; For each digit:
        (dolist (powerset position-powersets)
          ; For each set of digit positions:
          (dolist (digit-positions powerset)
            ; Skip the empty set
            (when digit-positions
              (let ((new-string (copy-seq prime-string)))
                (dolist (i digit-positions)
                  (setf (char new-string i) #\*))
                (push new-string generated-strings)))))
        generated-strings))

    (defun project-euler-51-1 (&optional (upper-limit 1000000)
                                         (num-primes-needed 8))
      (let ((primes (sieve-of-eratosthenes upper-limit))
            (counters (make-hash-table :test 'equal))
            (first-primes (make-hash-table :test 'equal)))

        (block check-each-prime
          (doarrayi (is-prime prime primes)
            (when is-prime
              (dolist (string-pattern (return-prime-family-candidates prime))
                (incf (gethash string-pattern counters 0))
                (when (not (gethash string-pattern first-primes))
                  (setf (gethash string-pattern first-primes) prime))
                (when (>= (gethash string-pattern counters)
                          num-primes-needed)
                  (return-from check-each-prime
                               (gethash string-pattern first-primes)))))))))

[[!tag LISP Project_Euler programming]]
