[Project Euler problem
61:](http://projecteuler.net/index.php?section=problems&id=61)

> Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
> all figurate (polygonal) numbers and are generated by the following formulae:
>
>     Triangle    P3,n=n(n+1)/2    1, 3, 6, 10, 15, ...
>     Square      P4,n=n*2         1, 4, 9, 16, 25, ...
>     Pentagonal  P5,n=n(3n-1)/2   1, 5, 12, 22, 35, ...
>     Hexagonal   P6,n=n(2n-1)     1, 6, 15, 28, 45, ...
>     Heptagonal  P7,n=n(5n-3)/2   1, 7, 18, 34, 55, ...
>     Octagonal   P8,n=n(3n-2)     1, 8, 21, 40, 65, ...
>
> The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
> interesting properties:
>
> * The set is cyclic, in that the last two digits of each number is the first
>   two digits of the next number (including the last number with the first).
> * Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
>   pentagonal (P5,44=2882), is represented by a different number in the set.
> * This is the only set of 4-digit numbers with this property.
>
> Find the sum of the only ordered set of six cyclic 4-digit numbers for which
> each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
> octagonal, is represented by a different number in the set.

We don't know in advance what order the numbers will be in, so we need to try
all 120 permutations.  My approach is simple:

1. Generate 6 lists of 4 digit polygonal numbers.
2. Generate 120 orderings of the 6 lists of numbers (chains).  There are 720
permutations of 6 items, but that produces 6 copies of each chain, each copy
being rotated by one position.  Instead, we generate all permutations of five
items, and start every chain with the same list.  This is a nice optimisation,
and we don't have to de-duplicate the results list.
3. For each ordering, traverse the chain, removing broken links.  When
traversing, we go down the chain, wrap around, then back up the chain.  In two
of the 120 orderings this leaves broken links, so we traverse the chain a second
time if necessary to correct this.
4. We should have a single chain that satisfies the requirements.  (We don't
need to check that the numbers are unique, but for correctness we should.)

Here's my LISP solution (some functions to generate polygonal numbers were
written for other problems and have been elided):

    (defun square-number (n)
      "Return the nth square number."
      (* n n))

    (defun heptagonal-number (n)
      "Return the nth heptagonal number."
      (/ (* n (- (* 5 n) 3)) 2))

    (defun octagonal-number (n)
      "Return the nth octagonal number."
      (* n (- (* n 3) 2)))

    (defun make-4-digit-polygonal-numbers (func)
      "Returns a list of 4 digit polygonal numbers created by successively calling
       (funcall func n)."
      (do* ((numbers '())
            (n 1 (1+ n))
            (latest-number (funcall func n) (funcall func n)))
           ((>= latest-number 10000) (nreverse numbers))
        (when (>= latest-number 1000)
          (push latest-number numbers))))

    (defun extract-ab (a-number)
      "Returns ab from abcd."
      (digits-to-number (subseq (number-to-digits a-number) 0 2)))

    (defun extract-cd (a-number)
      "Returns cd from abcd."
      (digits-to-number (subseq (number-to-digits a-number) 2 4)))

    (defun follow-4-digit-chain-link (left-links right-links)
      "The number abcd chains with the number cdef.  Given the lists left-links
       and right-links, this function will remove any left links that don't have
       corresponding right links and vice versa, returning new lists."
      (let ((cd-hash (make-hash-table))
            (ab-hash (make-hash-table))
            (new-left-list)
            (new-right-list))
        (dolist (left left-links)
          (setf (gethash (extract-cd left) cd-hash) t))
        (dolist (right right-links)
          (setf (gethash (extract-ab right) ab-hash) t))
        (setf new-left-list
              (remove-if-not #'(lambda (key)
                                 (gethash (extract-cd key) ab-hash))
                             left-links))
        (setf new-right-list
              (remove-if-not #'(lambda (key)
                                 (gethash (extract-ab key) cd-hash))
                             right-links))
        (values new-left-list new-right-list)))

    (defun follow-4-digit-chain-link-wrapper (chain left-index right-index)
      "A wrapper around follow-4-digit-chain-link to run it on two elements from an
       array, replacing the original values."
      (multiple-value-bind (left-links right-links)
                           (follow-4-digit-chain-link (aref chain left-index)
                                                      (aref chain right-index))
        (setf (aref chain left-index) left-links
              (aref chain right-index) right-links)))

    (defun remove-broken-4-digit-chain-links (number-chain)
      "Traverse a 4-digit chain, removing broken links.  The lists in the array
       number-chain will be modified."
      (let ((last-index (1- (length number-chain)))
            (num-links-in-index-0 (length (aref number-chain 0))))
        (dofromto (0 (1- last-index) i)
          (follow-4-digit-chain-link-wrapper number-chain i (1+ i)))
        (follow-4-digit-chain-link-wrapper number-chain last-index 0)
        (dofromto ((1- last-index) 0 i)
          (follow-4-digit-chain-link-wrapper number-chain i (1+ i)))
        ; We leave broken links when the following happens:
        ; 1 Traverse the chain in one direction, removing broken links.
        ; 2 Wrap around from index X to index 0, removing elements from index 0.
        ;   There are now elements in index 1 that don't have a link in index 0.
        ;   The only way to fix this is to traverse the chain again.
        ; Recurse when index 0 still has elements and we removed some elements from
        ; index 0.
        (when (and (not (zerop (length (aref number-chain 0))))
                   (not (= (length (aref number-chain 0)) num-links-in-index-0)))
          (remove-broken-4-digit-chain-links number-chain))))

    (defun project-euler-61-1 ()
      (let* ((polygonal-functions (list #'octagonal-number
                                        #'triangle-number
                                        #'square-number
                                        #'pentagonal-number
                                        #'hexagonal-number
                                        #'heptagonal-number))
             (num-polygonal-numbers (length polygonal-functions))
             (polygonal-numbers (make-array num-polygonal-numbers))
             (chains '()))
        ; Populate the array of polygonal numbers.
        (let ((i 0))
          (dolist (func polygonal-functions)
            (setf (aref polygonal-numbers i)
                  (make-4-digit-polygonal-numbers func))
            (incf i)))

        ; Generate all possible permutations of the list of polygonal numbers,
        ; excluding octagonal.  We start every chain with the octagonal numbers (any
        ; group would work), because '(0 1 2 3 4 5) rotated any number of times is
        ; the same chain, and there's no point in processing each chain six times.
        (dolist (permutation (permute '(1 2 3 4 5)))
          (let ((number-chain (make-array num-polygonal-numbers))
                (dest-index 0))
            (dolist (src-index (cons 0 permutation))
              (setf (aref number-chain dest-index)
                    (copy-seq (aref polygonal-numbers src-index)))
              (incf dest-index))
            (remove-broken-4-digit-chain-links number-chain)
            (when (not (zerop (length (aref number-chain 0))))
              (push number-chain chains))))

        (if (= 1 (length chains))
          (let ((sum 0)
                (chain (first chains)))
            (dotimes (index (length chain) sum)
              (incf sum (first (aref chain index)))))
          (progn
            (format t "expecting one chain, found ~A~%" (length chains))
            chains))))

[[!tag LISP Project_Euler programming]]
