[Project Euler problem
60:](http://projecteuler.net/index.php?section=problems&id=60)

> The primes 3, 7, 109, and 673, are quite remarkable. By taking any two primes
> and concatenating them in any order the result will always be prime. For
> example, taking 7 and 109, both 7109 and 1097 are prime. The sum of these four
> primes, 792, represents the lowest sum for a set of four primes with this
> property.
>
> Find the lowest sum for a set of five primes for which any two primes
> concatenate to produce another prime.

This solution is pretty simple:

1. Find all pairs `(ab cd)` such that:
   * `ab` is prime
   * `cd` is prime
   * `abcd` is prime
   * `cdab` is prime

   Generate a hash table mapping `(prime -> (list of connected primes)`.
2. Transform the hash table into a list of `(ab cd)` pairs representing two-node
fully-connected graphs.
3. From a list of N-node fully-connected graphs, you can generate a list of
N+1-node fully-connected graphs by performing these steps for each N-node graph
`G`:
   1. Pick a node `X` from `G`.
   2. For each node `Y` connected to `X`, if `Y` is connected to every node in
   `G`, `Y + G` is an N+1-node graph.
4. Use the algorithm above to generate lists of 3-node, 4-node, and 5-node
graphs.
5. Sum the values of each 5-node graph and pick the smallest.

Here's my LISP solution:

    (defun find-concatonating-prime-pairs (sieve)
      "Find pairs (ab cd) such that ab, cd, abcd, and cdab are prime.  Returns a
       hash table mapping (prime -> list of primes), e.g.
       #S(HASH-TABLE (ab . (cd)) (cd . (ab)))"
      (let ((prime-pairs (make-hash-table))
            (upper-bound (1- (array-dimension sieve 0))))
        (dofromto (2 upper-bound prime1 prime-pairs)
          (when (is-prime sieve prime1)
            (dofromto (prime1 upper-bound prime2)
              (when (is-prime sieve prime2)
                (let* ((digits1 (number-to-digits prime1))
                       (digits2 (number-to-digits prime2))
                       (concat-digits1 (concatenate 'list digits1 digits2))
                       (concat-digits2 (concatenate 'list digits2 digits1))
                       (concat-number1 (digits-to-number concat-digits1))
                       (concat-number2 (digits-to-number concat-digits2)))
                  (when (and (not (= prime1 prime2))
                             ; Numbers with leading digits confuse things.
                             (not (= 0 (first concat-digits1)))
                             (not (= 0 (first concat-digits2)))
                             (is-prime sieve concat-number1)
                             (is-prime sieve concat-number2))
                    (push prime2 (gethash prime1 prime-pairs '()))
                    (push prime1 (gethash prime2 prime-pairs '()))))))))))

    (defun make-pair-graphs (hash)
      "Returns a deduplicated list of pairs.  Each pair will have the lower-valued
       element first."
      (let ((sub-graphs '()))
        (maphash #'(lambda (node-1 list-of-nodes)
                     (dolist (node-2 list-of-nodes)
                       (push (sort (list node-1 node-2) #'<) sub-graphs)))
                 hash)
        (delete-duplicates sub-graphs :test #'equal)))

    (defun generate-n+1-node-graphs (n-node-graphs pairs-hash)
      "Generate n+1 node graphs from n-node graphs.  Returns a deduplicated list.
       The nodes in each graph are in ascending order."
      (let ((n+1-node-graphs '()))
        (dolist (n-node-graph n-node-graphs)
          (let ((first-node (first n-node-graph))
                (other-nodes (rest n-node-graph)))
            (dolist (possibly-connected-node (gethash first-node pairs-hash))
              (block next-node
                (dolist (connected-node other-nodes)
                  (when (not (member possibly-connected-node
                                     (gethash connected-node pairs-hash)))
                    (return-from next-node)))
                (push (sort (append n-node-graph (list possibly-connected-node))
                            #'<)
                      n+1-node-graphs)))))
        (delete-duplicates n+1-node-graphs :test #'equal)))

    (defun project-euler-60-1 (&optional (upper-bound 10000))
      (let* ((sieve (sieve-of-eratosthenes upper-bound))
             (pairs-hash (find-concatonating-prime-pairs sieve))
             (graphs (make-pair-graphs pairs-hash)))
        (dofromto (3 5 i)
          (setf graphs (generate-n+1-node-graphs graphs pairs-hash)))
        (first (sort (mapcar #'(lambda (graph)
                                 (apply #'+ graph))
                             graphs)
                     #'<))))

[[!tag LISP Project_Euler programming]]
