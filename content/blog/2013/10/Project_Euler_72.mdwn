[Project Euler problem 72:](http://projecteuler.net/problem=72)

> Consider the fraction, n/d, where n and d are positive integers. If n < d and
> HCF(n,d)=1, it is called a reduced proper fraction.
>
> If we list the set of reduced proper fractions for d <= 8 in ascending order
> of size, we get:
>
> 1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3,
> 5/7, 3/4, 4/5, 5/6, 6/7, 7/8
>
> It can be seen that there are 21 elements in this set.
>
> How many elements would be contained in the set of reduced proper fractions
> for d <= 1,000,000?

A reduced proper fraction has gcd(numerator, denominator) == 1, which means
the numerator is relatively prime to the denominator.  The number of reduced
proper fractions with denominator D is the number of relatively prime integers
less than D; this is Euler's Totient function, phi.  To calculate phi for a
number, generate all the prime numbers less than the number, and multiply (1 -
1/prime) for all prime numbers (see
[Wikipedia](http://en.wikipedia.org/wiki/Euler's_totient_function#Euler.27s_product_formula)).
Rather than calculating all the primes for each denominator, we can use a
method similar to the Sieve of Eratosthenes:

- initialise an array so that array[i] = i;
- iterate over the array from 2 onwards; when array[i] == i, that's a prime
  number, and we multiply every multiple of i by (1 - 1/i).

Now we know phi(denominator) for every denominator, so we sum them to get the
answer to the problem.


Here's my Go solution:

    func MakePhiLookupTable(size int) []int64 {
    	table := make([]float64, size + 1)
    	for i := range table {
    		table[i] = float64(i)
    	}
    	for i := range table {
    		if i <= 1 || table[i] != float64(i) {
    			// i is not prime.
    			continue
    		}
    		for j := i; j <= size; j += i {
    			tmp := float64(i)
    			table[j] *= (1 - 1/tmp)
    		}
    	}
    	result := make([]int64, size + 1)
    	for i, value := range table {
    		result[i] = int64(value)
    	}
    	return result
    }

    func projectEuler72actual(size int) int64 {
    	phi_table := MakePhiLookupTable(size)
    	var total int64 = 0
    	for _, value := range phi_table {
    		total += value
    	}
    	// 1/1 is not a reduced proper fraction, because the numerator must be
    	// less than the denominator.
    	total -= phi_table[1]
    	return total
    }

    func projectEuler72test() int64 {
    	return projectEuler72actual(8)
    }

    func projectEuler72() int64 {
    	return projectEuler72actual(1000000)
    }

[[!tag Golang Project_Euler programming]]
