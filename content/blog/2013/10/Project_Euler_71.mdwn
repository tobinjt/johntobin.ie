[Project Euler problem 71:](http://projecteuler.net/problem=71)

> Consider the fraction, n/d, where n and d are positive integers. If n < d and
> HCF(n,d)=1, it is called a reduced proper fraction.
>
> If we list the set of reduced proper fractions for d <= 8 in ascending order of
> size, we get:
>
> 1/8, 1/7, 1/6, 1/5, 1/4, 2/7, 1/3, 3/8, 2/5, 3/7, 1/2, 4/7, 3/5, 5/8, 2/3,
> 5/7, 3/4, 4/5, 5/6, 6/7, 7/8
>
> It can be seen that 2/5 is the fraction immediately to the left of 3/7.
>
> By listing the set of reduced proper fractions for d <= 1,000,000 in ascending
> order of size, find the numerator of the fraction immediately to the left of
> 3/7.

We have upper (2/5) and lower (3/7) bounds, so we don't need to search the
entire problem space.  We don't need to generate all the possible fractions
between the lower and upper bounds: every time we find a fraction that is
better than our current lower bound, we can tighten the lower bound, and the
lower bound will eventually be our answer.  We do need to generate all
denominators from 5 to 1,000,000; but for each denominator, the first
numerator we use will be the numerator of the current lower bound, and we stop
incrementing the numerator when the current fraction exceeds the upper bound.
If any of the fractions we generate are better than the current lower bound,
we replace the lower bound with that fraction.

Here's my Go solution:

    func GreatestCommonDenominator(a, b int64) int64 {
    	return big.NewInt(0).GCD(nil, nil, big.NewInt(a), big.NewInt(b)).Int64()
    }

    func projectEuler71() int64 {
    	return projectEuler71actual(1000000)
    }

    func projectEuler71test() int64 {
    	// This function is for testing projectEuler71actual, because it takes
    	// about 30 seconds to do the real calculation.
    	return projectEuler71actual(8)
    }

    func projectEuler71actual(max_denominator int64) int64 {
    	upper_bound := big.NewRat(3, 7)
    	answer := big.NewRat(1, 5)
    	var denominator int64
    	for denominator = 1; denominator <= max_denominator; denominator++ {
    		numerator := answer.Num().Int64()
    		current := big.NewRat(numerator, denominator)
    		for upper_bound.Cmp(current) == 1 {
    			if GreatestCommonDenominator(numerator, denominator) ==
    				1 && answer.Cmp(current) == -1 {
    				answer.Set(current)
    			}
    			numerator++
    			current = big.NewRat(numerator, denominator)
    		}
    	}
    	return answer.Num().Int64()
    }

[[!tag Golang Project_Euler programming]]
