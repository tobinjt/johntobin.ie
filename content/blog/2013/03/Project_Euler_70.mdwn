[Project Euler problem 70:](http://projecteuler.net/problem=70)


> Euler's Totient function, φ(n) [sometimes called the phi function], is used to
> determine the number of positive numbers less than or equal to n which are
> relatively prime to n. For example, as 1, 2, 4, 5, 7, and 8, are all less than
> nine and relatively prime to nine, φ(9)=6.
> The number 1 is considered to be relatively prime to every positive number, so
> φ(1)=1.
>
> Interestingly, φ(87109)=79180, and it can be seen that 87109 is a permutation
> of 79180.
>
> Find the value of n, 1 <= n <= 10**7, for which φ(n) is a permutation of n and
> the ratio n/φ(n) produces a minimum.


> http://www.doc.ic.ac.uk/~mrh/330tutor/ch05s02.html
>
> - when n is a prime number (e.g. 2, 3, 5, 7, 11, 13), φ(n) = n-1.
> - when m and n are coprime, φ(m*n) = φ(m)*φ(n).
> - If the prime factorisation of n is given by n =p1e1*...*pnen, then
>   φ(n) = n *(1 - 1/p1)* ... (1 - 1/pn).


> To minimise n/φ(n), we need to:
>
> - minimise the difference between n and φ(n), by minimising the number of
>   prime factors in n.
> - maximise n so that the difference between n and φ(n) is a small fraction of
>   n.
>
> Pick a threshold, e.g. sqrt(bound)*1.5, find the primes below it, sort them in
> descending order, generate all the pairs, and test them.  If the bound is too
> low, increase it; if pairs don't work, try triples.


Here's my Go solution:

    func IntsArePermutations(a, b int) bool {
    	exists := make(map[int]int)
    	for a > 0 {
    		exists[int(a%10)]++
    		a /= 10
    	}
    	for b > 0 {
    		exists[int(b%10)]--
    		b /= 10
    	}
    	for _, count := range exists {
    		if count != 0 {
    			return false
    		}
    	}
    	return true
    }

    func projectEuler70() int64 {
    	bound := 10 * 1000 * 1000
    	prime_bound := int(1.5 * math.Sqrt(float64(bound)))
    	sieve := SieveOfEratosthenes(prime_bound + 1)
    	primes := make([]int, 0)
    	for prime, is_prime := range sieve {
    		if !is_prime {
    			continue
    		}
    		primes = append(primes, prime)
    	}

    	permutation := NewIntPermutation(primes, 2)
    	Permute(&permutation)
    	number := 0
    	ratio := 10.0
    	for _, pair := range permutation.dest {
    		n := pair[0] * pair[1]
    		if n > bound {
    			continue
    		}
    		phi_n := (pair[0] - 1) * (pair[1] - 1)
    		ratio_n := float64(n) / float64(phi_n)
    		if ratio_n < ratio && IntsArePermutations(n, phi_n) {
    			ratio = ratio_n
    			number = n
    		}
    	}

    	return int64(number)
    }

[[!tag Golang Project_Euler programming]]
