[Project Euler problem 92:](http://projecteuler.net/problem=92)

> A number chain is created by continuously adding the square of the digits in
> a number to form a new number until it has been seen before.
>
> For example,
>
> 44 → 32 → 13 → 10 → 1 → 1
> 85 → 89 → 145 → 42 → 20 → 4 → 16 → 37 → 58 → 89
>
> Therefore any chain that arrives at 1 or 89 will become stuck in an endless
> loop. What is most amazing is that EVERY starting number will eventually
> arrive at 1 or 89.
>
> How many starting numbers below ten million will arrive at 89?

Here's my Go solution:

    /*
     * The biggest possible number to check is 9999999 -> 81*7 -> 567, so we
     * maintain a cache of 568 elements mapping to 1 or 89.
     */
    const _SQUARE_CHAIN_CACHE_SIZE uint = 568

    /*
    * Return the last element in the square chain for number, either 1 or 89.
    * cache is used to short circuit following the chain and is updated.
     */
    func squareChain(number uint, cache []uint) uint {
    	if number < _SQUARE_CHAIN_CACHE_SIZE && cache[number] != 0 {
    		return cache[number]
    	}
    	var sum uint
    	num := number
    	for num != 0 {
    		digit := num % 10
    		num = num / 10
    		sum += digit * digit
    	}
    	result := squareChain(sum, cache)
    	if number < _SQUARE_CHAIN_CACHE_SIZE {
    		cache[number] = result
    	}
    	return result
    }

    func projectEuler92actual(limit uint) int64 {
    	cache := make([]uint, _SQUARE_CHAIN_CACHE_SIZE)
    	cache[1] = 1
    	cache[89] = 89
    	count_1, count_89 := 0, 0
    	for i := uint(1); i < limit; i++ {
    		result := squareChain(i, cache)
    		if result == 1 {
    			count_1++
    		} else {
    			count_89++
    		}
    	}
    	return int64(count_89)
    }

    func projectEuler92test() int64 {
    	return projectEuler92actual(10)
    }

    func projectEuler92() int64 {
    	return projectEuler92actual(10 * 1000 * 1000)
    }

[[!tag Golang Project_Euler programming]]
