[Project Euler problem 78:](http://projecteuler.net/problem=78)

> Let p(n) represent the number of different ways in which n coins can be
> separated into piles. For example, five coins can separated into piles in
> exactly seven different ways, so p(5)=7.
>
> * OOOOO
> * OOOO   O
> * OOO   OO
> * OOO   O   O
> * OO   OO   O
> * OO   O   O   O
> * O   O   O   O   O
> Find the least value of n for which p(n) is divisible by one million.

Calling `NumIntegerPartitions` from PE 76 in a loop was my initial approach, but
that failed because performance falls off a cliff:

* 7.307216ms 6028 => -5051972599416803847
* 9.74248ms 6029 => 1953721510414805365
* 3.615389811s 6030 => -9113343080961881073
* 257.840184ms 6031 => 63892779937861297
* 227.194138ms 6032 => 8738253903924976475
* 223.567489ms 6033 => 5975595644718247526

I read a lot of different articles about Integer Partitions, but I finally
figured out a working algorithm after reading
<http://en.wikipedia.org/wiki/Partition_(number_theory)#Generating_function>
several times.

Later it became obvious that `int64` was not large enough to hold the results,
so I switched to `math.big.Int`.  That's a couple of orders of magnitude slower
than `int64`, but is still an order of magnitude faster than
`NumIntegerPartitions` and finds the answer in about 12 seconds.

Here's my Go solution:

    func PentagonalNumber(number int) int {
    	return ((3 * number * number) - number) / 2
    }

    func GeneralisedPentagonalNumber(number int) int {
    	// input:   0, 1,  2, 3,  4, 5,  6, 7,  8
    	// becomes: 0, 1, -1, 2, -2, 3, -3, 4, -4
    	if number%2 == 0 {
    		return PentagonalNumber(number / -2)
    	} else {
    		return PentagonalNumber((number + 1) / 2)
    	}
    }

    var IPresults2 map[int]*big.Int = map[int]*big.Int{0: big.NewInt(1)}

    /*
    * The formula is described in
    * http://en.wikipedia.org/wiki/Partition_(number_theory)#Generating_function
    * but it needs a bit of interpretation to get something that you can implement.
     */
    func NumIntegerPartitions2(number int) *big.Int {
    	result, exists := IPresults2[number]
    	if exists {
    		return result
    	}
    	// This is rotated one place to the right because we start with i=1
    	// rather than i=0.
    	signs := []*big.Int{big.NewInt(-1), big.NewInt(1), big.NewInt(1),
    		big.NewInt(-1)}
    	sum, i := big.NewInt(0), 0
    	for {
    		i++
    		pentagonal_number := GeneralisedPentagonalNumber(i)
    		if pentagonal_number > number {
    			break
    		}
    		num_ip := NumIntegerPartitions2(number - pentagonal_number)
    		temp := big.NewInt(0)
    		temp.Mul(signs[i%len(signs)], num_ip)
    		sum.Add(sum, temp)
    	}
    	IPresults2[number] = sum
    	return sum
    }

    func projectEuler78actual(multiple int64) int64 {
    	big_multiple := big.NewInt(multiple)
    	modulus := big.NewInt(0)
    	i := 0
    	for {
    		i++
    		nip := NumIntegerPartitions2(i)
    		modulus.Mod(nip, big_multiple)
    		if modulus.Int64() == 0 {
    			return int64(i)
    		}
    	}
    }

    func projectEuler78test() int64 {
    	return projectEuler78actual(7)
    }

    func projectEuler78() int64 {
    	return projectEuler78actual(1000 * 1000)
    }

[[!tag Golang Project_Euler programming]]
