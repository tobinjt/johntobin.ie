[Project Euler problem 77:](http://projecteuler.net/problem=77)

> It is possible to write ten as the sum of primes in exactly five different
> ways:
>
> * 7 + 3
> * 5 + 5
> * 5 + 3 + 2
> * 3 + 3 + 2 + 2
> * 2 + 2 + 2 + 2 + 2
>
> What is the first value which can be written as the sum of primes in over five
> thousand different ways?

The [formula for calculating the number of prime
partitions](http://oeis.org/A000607) is voodoo, and it's not good for
implementing an algorithm.  The formula can be transformed using [Euler's
Transform](http://mathworld.wolfram.com/EulerTransform.html) into [something
that can be implemented reasonably
easily](http://math.stackexchange.com/a/89661).  I admit that I don't understand
*why* or *how* either of these formulae work.

Here's my Go solution:

    func SumOfPrimeFactors(number int, sieve []bool) int {
    	factors := PrimeFactors(number, sieve)
    	sum := 0
    	last_factor := 0
    	for _, factor := range factors {
    		if factor != last_factor {
    			sum += factor
    			last_factor = factor
    		}
    	}
    	return sum
    }

    func SumOfPrimeFactors_Cached(number int, sieve []bool, sopf_cache map[int]int) int {
    	result, exists := sopf_cache[number]
    	if !exists {
    		result = SumOfPrimeFactors(number, sieve)
    		sopf_cache[number] = result
    	}
    	return result
    }

    func NumPrimePartitions(number int, sieve []bool, npp_cache map[int]int,
    	sopf_cache map[int]int) int {
    	if number == 1 {
    		return 0
    	}
    	result, exists := npp_cache[number]
    	if exists {
    		return result
    	}

    	sum := SumOfPrimeFactors_Cached(number, sieve, sopf_cache)
    	for j := 1; j < number; j++ {
    		sopf_j := SumOfPrimeFactors_Cached(j, sieve, sopf_cache)
    		npp_number_minus_j := NumPrimePartitions(number-j, sieve,
    			npp_cache, sopf_cache)
    		sum += npp_number_minus_j * sopf_j
    	}
    	result = sum / number
    	// Without caching, the time taken to calculate NumPrimePartitions(n) is
    	// O(2^n).  n=29 is when it takes longer than 1 minute on my laptop.
    	npp_cache[number] = result
    	return result
    }

    func projectEuler77actual(target int) int64 {
    	sieve := SieveOfEratosthenes(100)
    	npp_cache := make(map[int]int)
    	sopf_cache := make(map[int]int)

    	number, result := 0, 0
    	for number = 1; result < target; number++ {
    		result = NumPrimePartitions(number, sieve, npp_cache,
    			sopf_cache)
    	}
    	return int64(number - 1)
    }

    func projectEuler77test() int64 {
    	return projectEuler77actual(26)
    }
    func projectEuler77() int64 {
    	return projectEuler77actual(5000)
    }

[[!tag Golang Project_Euler programming]]
