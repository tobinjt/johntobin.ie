[Project Euler problem 80:](http://projecteuler.net/problem=80)

> It is well known that if the square root of a natural number is not an
> integer, then it is irrational. The decimal expansion of such square roots is
> infinite without any repeating pattern at all.
>
> The square root of two is 1.41421356237309504880..., and the digital sum of
> the first one hundred decimal digits is 475.
>
> For the first one hundred natural numbers, find the total of the digital sums
> of the first one hundred decimal digits for all the irrational square roots.

This took quite a while to solve.  First I had to find an algorithm, then
translate it to something I could code.  That seemed to work, and even passed the
unit tests I wrote, until I tried higher precision roots.  I found that 64bit
ints were not precise enough, so I converted to `big.Int`.  Then I had something
that mostly worked, except I has slightly misunderstood both the question and
the algorithm.  After fixing those misunderstandings I finally had a working
solution.  Now to read the forum thread and find that some people solved it with
10 minutes of coding x86 assembler on a 386 :)

Here's my Go solution:

    // http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Decimal_.28base_10.29
    // The numbered comments in the function refer to the steps in the Wikipedia
    // article.
    func SqrtPE80(number, precision int) []int {
    	digit_stack := []int{}
    	for remainder := number; remainder > 0; remainder /= 10 {
    		digit_stack = append(digit_stack, remainder%10)
    	}
    	// Pad the digit stack so that an odd number of digits is interpreted
    	// as 0A, BC rather than AB, 0C.
    	if len(digit_stack)%2 == 1 {
    		digit_stack = append(digit_stack, 0)
    	}
    	digit_stack_i := len(digit_stack) - 1

    	remainder, root_so_far := big.NewInt(0), big.NewInt(0)
    	zero, one := big.NewInt(0), big.NewInt(1)
    	ten, twenty := big.NewInt(10), big.NewInt(20)
    	result := make([]int, 0)
    	for len(result) < precision {
    		// Step 1.
    		current := big.NewInt(0)
    		current.Set(remainder)
    		for j := 0; j < 2; j++ {
    			current = current.Mul(current, ten)
    			if digit_stack_i >= 0 {
    				current.Add(current,
    					big.NewInt(int64(digit_stack[digit_stack_i])))
    			}
    			digit_stack_i--
    		}

    		// Step 2.
    		next_digit, subtract_me := big.NewInt(0), big.NewInt(0)
    		for {
    			next_digit.Add(next_digit, one)
    			temp := big.NewInt(0)
    			temp.Set(root_so_far)
    			temp.Mul(temp, twenty)
    			temp.Add(temp, next_digit)
    			temp.Mul(temp, next_digit)
    			if temp.Cmp(current) == 1 {
    				next_digit.Sub(next_digit, one)
    				break
    			}
    			subtract_me.Set(temp)
    		}

    		// Step 3.
    		remainder.Sub(current, subtract_me)
    		root_so_far.Mul(root_so_far, ten)
    		root_so_far.Add(root_so_far, next_digit)
    		result = append(result, int(next_digit.Int64()))

    		// Step 4.
    		if remainder.Cmp(zero) == 0 && digit_stack_i < 0 {
    			break
    		}
    	}
    	return result
    }

    func projectEuler80actual(upper_bound int) int64 {
    	result := 0
    	for i := 0; i <= upper_bound; i++ {
    		sqrt := SqrtPE80(i, 100)
    		// Irrational roots will have more than a single digit.  I'm
    		// cheating somewhat because I know this function won't be
    		// called with an upper bound >99.
    		if len(sqrt) > 1 {
    			for j := 0; j < len(sqrt); j++ {
    				result += sqrt[j]
    			}
    		}
    	}
    	return int64(result)
    }

    func projectEuler80test() int64 {
    	return projectEuler80actual(2)
    }

    func projectEuler80() int64 {
    	return projectEuler80actual(99)
    }

[[!tag Golang Project_Euler programming]]
