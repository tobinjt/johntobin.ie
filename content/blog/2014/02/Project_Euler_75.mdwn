[Project Euler problem 75:](http://projecteuler.net/problem=75)

> It turns out that 12 cm is the smallest length of wire that can be bent to
> form an integer sided right angle triangle in exactly one way, but there are
> many more examples.
>
> * 12 cm: (3,4,5)
> * 24 cm: (6,8,10)
> * 30 cm: (5,12,13)
> * 36 cm: (9,12,15)
> * 40 cm: (8,15,17)
> * 48 cm: (12,16,20)
>
> In contrast, some lengths of wire, like 20 cm, cannot be bent to form an
> integer sided right angle triangle, and other lengths allow more than one
> solution to be found; for example, using 120 cm it is possible to form exactly
> three different integer sided right angle triangles.
>
> 120 cm: (30,40,50), (20,48,52), (24,45,51)
>
> Given that L is the length of the wire, for how many values of L â‰¤ 1,500,000
> can exactly one integer sided right angle triangle be formed?
>

I'm going to take a similar approach to Sieve of Eratosthenes.  Initialise an
array of 1.5M ints.  Start with 3, 4, 5, then generate all the child triples.
Maintain a queue of children, sum the lengths of each child, and increment every
multiple of that sum.  Eventually there will be no more children whose sum is
<=1.5M.  Then count all the array elements whose value is 1, and that's the
answer.


Here's my Go solution:

    type PythagoreanTriple struct {
    	a, b, c int
    }

    // Generate three child PythagoreanTriple from a parent PythagoreanTriple.
    // http://en.wikipedia.org/wiki/Pythagorean_triple#Parent.2Fchild_relationships
    func (parent PythagoreanTriple) MakeChildren() []PythagoreanTriple {
    	child1 := PythagoreanTriple{
    		a: parent.a - (2 * parent.b) + (2 * parent.c),
    		b: (2 * parent.a) - parent.b + (2 * parent.c),
    		c: (2 * parent.a) - (2 * parent.b) + (3 * parent.c),
    	}
    	child2 := PythagoreanTriple{
    		a: parent.a + (2 * parent.b) + (2 * parent.c),
    		b: (2 * parent.a) + parent.b + (2 * parent.c),
    		c: (2 * parent.a) + (2 * parent.b) + (3 * parent.c),
    	}
    	child3 := PythagoreanTriple{
    		a: (-1 * parent.a) + (2 * parent.b) + (2 * parent.c),
    		b: (-2 * parent.a) + parent.b + (2 * parent.c),
    		c: (-2 * parent.a) + (2 * parent.b) + (3 * parent.c),
    	}
    	return []PythagoreanTriple{
    		child1,
    		child2,
    		child3,
    	}
    }

    func projectEuler75() int64 {
    	return projectEuler75_actual(1500000)
    }

    func projectEuler75test() int64 {
    	return projectEuler75_actual(100)
    }

    func projectEuler75_actual(upper_bound int) int64 {
    	counts := make([]int, upper_bound+1)
    	triples := make([]PythagoreanTriple, 1)
    	triples[0] = PythagoreanTriple{a: 3, b: 4, c: 5}

    	for index := 0; index < len(triples); index++ {
    		triple := triples[index]
    		children := triple.MakeChildren()
    		for _, child := range children {
    			sum := child.a + child.b + child.c
    			if sum <= upper_bound {
    				triples = append(triples, child)
    			}
    		}

    		sum := triple.a + triple.b + triple.c
    		multiple := sum
    		for multiple <= upper_bound {
    			counts[multiple]++
    			multiple += sum
    		}
    	}

    	result := 0
    	for _, count := range counts {
    		if count == 1 {
    			result++
    		}
    	}
    	return int64(result)
    }

[[!tag Golang Project_Euler programming]]
