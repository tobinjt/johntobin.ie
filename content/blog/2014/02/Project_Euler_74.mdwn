[Project Euler problem 74:](http://projecteuler.net/problem=74)

> The number 145 is well known for the property that the sum of the factorial of
> its digits is equal to 145:
>
> 1! + 4! + 5! = 1 + 24 + 120 = 145
>
> Perhaps less well known is 169, in that it produces the longest chain of
> numbers that link back to 169; it turns out that there are only three such
> loops that exist:
>
> 169 → 363601 → 1454 → 169
> 871 → 45361 → 871
> 872 → 45362 → 872
>
> It is not difficult to prove that EVERY starting number will eventually get
> stuck in a loop. For example,
>
> 69 → 363600 → 1454 → 169 → 363601 (→ 1454)
> 78 → 45360 → 871 → 45361 (→ 871)
> 540 → 145 (→ 145)
>
> Starting with 69 produces a chain of five non-repeating terms, but the longest
> non-repeating chain with a starting number below one million is sixty terms.
>
> How many chains, with a starting number below one million, contain exactly
> sixty non-repeating terms?

I started with heavy caching, and fought to get it right in all the possible
cases, but then I found that removing the caching gave me a >25% performance
boost.  The non-caching version is not just faster, it's much simpler and
clearer.

Here's my Go solution:

    func CalculateFactorialSum(number int) int {
    	factorials := []int{1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880}
    	if number == 0 {
    		return factorials[number]
    	}
    	sum := 0
    	for number > 0 {
    		digit := number % 10
    		sum += factorials[digit]
    		number /= 10
    	}
    	return sum
    }

    func CalculateFactorialChainLength(number int) int {
    	sum := CalculateFactorialSum(number)
    	// The problem tells us that the longest non-repeating chain contains 60
    	// elements.
    	chain := make([]int, 62)
    	chain[0] = number
    	chain[1] = sum
    	chain_index := 2

    	for {
    		sum = CalculateFactorialSum(sum)
    		// Check if we have found a loop.
    		for i := 0; i < chain_index; i++ {
    			if chain[i] == sum {
    				return chain_index
    			}
    		}
    		// Still no loop, extend the chain.
    		chain[chain_index] = sum
    		chain_index++
    	}
    }

    func projectEuler74() int64 {
    	count := 0
    	for i := 1; i < 1000000; i++ {
    		if CalculateFactorialChainLength(i) == 60 {
    			count++
    		}
    	}
    	return int64(count)
    }

[[!tag Golang Project_Euler programming]]
